package com.cablemc.pokemoncobbled.common.api.spawning

import com.cablemc.pokemoncobbled.common.api.spawning.prospecting.SpawningProspector
import net.minecraft.world.level.Level
import net.minecraft.world.level.block.Blocks
import net.minecraft.world.level.block.state.BlockState
import kotlin.math.max

/**
 * A slice of the world that can be accessed safely from an async thread. This includes all of the information
 * that might be unsafe to access async from the world itself for the purposes of spawning.
 *
 * This is generated by a [SpawningProspector].
 *
 * @author Hiroku
 * @since January 31st, 2022
 */
class WorldSlice(
    val cause: Any,
    val level: Level,
    val baseX: Int,
    val baseY: Int,
    val baseZ: Int,
    val blocks: Array<Array<Array<BlockState>>>,
    val lights: Array<Array<Array<Int>>>,
    val skyLevel: Array<Array<Int>>
) {
    val length = blocks.size
    val height = blocks[0].size
    val width = blocks[0][0].size

    val stoneState = Blocks.STONE.defaultBlockState()

    fun isInBounds(x: Int, y: Int, z: Int) = x >= baseX && x < baseX + length && y >= baseY && y < baseY + height && z >= baseZ && z < baseZ + width

    fun getBlockState(x: Int, y: Int, z: Int, elseBlock: BlockState = stoneState): BlockState {
        return if (!isInBounds(x, y, z)) {
            elseBlock
        } else {
            blocks[x][y][z]
        }
    }

    fun getLight(x: Int, y: Int, z: Int, elseLight: Int = 0): Int {
        return if (!isInBounds(x, y, z)) {
            elseLight
        } else {
            lights[x][y][z]
        }
    }

    fun skySpaceAbove(x: Int, y: Int, z: Int): Int {
        return if (!isInBounds(x, y, z) || skyLevel[x][z] > y) {
            0
        } else {
            max(0, level.maxBuildHeight - y)
        }
    }

    fun skyAbove(x: Int, y: Int, z: Int, elseSkyAbove: Boolean = false): Boolean {
        return if (!isInBounds(x, y, z)) {
            elseSkyAbove
        } else {
            skyLevel[x][z] <= y
        }
    }

    fun horizontalSpace(centerX: Int, centerY: Int, centerZ: Int, condition: (BlockState) -> Boolean, maximum: Int): Int {
        var space = 1
        var radius = 1
        while (radius <= maximum) {
            val minX = centerX - radius
            val maxX = centerX + radius
            val minZ = centerZ - radius
            val maxZ = centerZ + radius

            if (!isInBounds(minX, centerY, minZ) || !isInBounds(maxX, centerY, maxZ)) {
                return space
            }

            // Check left side of square
            var x = minX
            var z = minZ
            while (z <= maxZ) {
                if (!condition(getBlockState(x, centerY, z))) {
                    return space
                }

                z++
            }

            // Check right side of square
            x = maxX
            z = minZ
            while (z <= maxZ) {
                if (!condition(getBlockState(x, centerY, z))) {
                    return space
                }

                z++
            }

            // Check bottom side of square minus the corners (minX and maxX)
            z = minZ
            x = minX + 1
            while (x < maxX) {
                if (!condition(getBlockState(x, centerY, z))) {
                    return space
                }

                x++
            }

            // Check top side of square minus the corners (minX and maxX)
            z = maxZ
            x = minX + 1
            while (x < maxX) {
                if (!condition(getBlockState(x, centerY, z))) {
                    return space
                }

                x++
            }

            radius++
            space += 2
        }

        return space
    }

    fun heightSpace(centerX: Int, centerY: Int, centerZ: Int, condition: (BlockState) -> Boolean, maximum: Int): Int {
        var space = 1
        while (space <= maximum) {
            val y = centerY + space
            if (y >= baseY + height) {
                return space
            }

            if (!condition(getBlockState(centerX, y, centerZ))) {
                return space
            }

            space++
        }

        return space
    }

    fun depthSpace(centerX: Int, centerY: Int, centerZ: Int, condition: (BlockState) -> Boolean, maximum: Int): Int {
        var space = 1
        while (space <= maximum) {
            val y = centerY - space
            if (y < baseY) {
                return space
            }

            if (!condition(getBlockState(centerX, y, centerZ))) {
                return space
            }

            space++
        }

        return space
    }
}